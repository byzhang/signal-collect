#summary Example Signal/Collect algorithm using the Java API

= Example Algorithm Java API =

An algorithm that can be naturally expressed as a Signal/Collect computation is the Single Source Shortest Path (SSSP) algorithm. For this algorithm we need a graph of connected vertices where exactly one vertex serves as the source of the graph and we compute the shortest distance from this source vertex to any other vertex in the graph. The distance is expressed as the sum of the weights of all the edges traversed on the path between the source and another vertex.

To fit this algorithm in the computation model of Signal/Collect we need to describe the computation from the perspective of a vertex. A vertex can learn about its distance to the source by comparing the distance of its neighbors to the source plus the weight of the incoming edge from this neighbor. When the vertex has learned about a shorter distance than the currently assumed one it needs to inform its own neighbors about this fact. If the distance does not change there is no need for the vertex to send out new updates because it's neighbors already know about its distance. This guaranties the global convergence of the SSSP algorithm (assuming a non-negative edge weight of course).

== Vertex implementation (Collect) ==
To achieve the behavior described above, the vertex must collect its received signals by computing the minimum among all signals and the current state. The full implementation of the collect function is shown here:
{{{
public Integer collect(Integer oldState, Iterable<Integer> mostRecentSignals) {
	int minDistance = oldState;
	for (int signal : mostRecentSignals) {
		if (signal < minDistance) {
			minDistance = signal;
		}
	}
	return minDistance;
}
}}}
The returned value of the collect function then automatically becomes the new state of the vertex. If this assignment changes the current value of the vertex's state, this vertex needs to forward its new state to all its neighbors. In case the state did not change after the execution of the collect function, the vertex does not have to signal any state updates. This local decision is responsible for the overall convergence of the SSSP algorithm which means that each vertex reachable from the source vertex has found its minimal distance to the source.

Initially all vertices are initialized to a value that is definitely larger than the longest shortest distance between the source vertex and any other vertex in the graph. This means that whenever the first update message arrives at any vertex the state will definitely update to a smaller value then the initialization state. If the algorithm converges and a vertex still holds it's initialization state, it means that the vertex has never received any update message and is therefore not reachable from the source vertex of the SSSP graph.

Here the complete implementation of the vertex:
{{{
import com.signalcollect.javaapi.DataGraphVertex;
import java.lang.Iterable;

@SuppressWarnings("serial")
public class SSSPNode extends DataGraphVertex<Integer, Integer, Integer> {

	public SSSPNode(int id) {
		this(id, Integer.MAX_VALUE);
	}

	public SSSPNode(int id, int initialDistance) {
		super(id, initialDistance);
	}

	@Override
	public Integer collect(Integer oldState, Iterable<Integer> mostRecentSignals) {
		int minDistance = oldState;
		for (int signal : mostRecentSignals) {
			if (signal < minDistance) {
				minDistance = signal;
			}
		}
		return minDistance;
	}

}
}}}

== Edge implementation (Signal) ==
Now that we know how to process incoming signals to compute the new state for a vertex we take a closer look on how to send these state-update signals from one vertex to the vertices it links to. To forward the state update to neighbors we use edge objects that handle the generation and forwarding of the signals. Because the relationship between two vertices in a graph can have different characteristics depending on which vertices are connected, we use a separate edge object to specify the connection between two vertices rather than including a collection of neighbors in the vertex itself.

For our SSSP graph, an edge holds the following static information:
  * The id of the source vertex
  * The id of the target vertex
  * The weight of the path (default value = 1.0)

Together with the current state of the source vertex is enough to compute the signal that should be sent along the edge from the source to the target vertex. Again we use the a predefined library class that handles generic edge functionality such as how to forward the computed signal to the target vertex. The library class `DefaultEdge` that is used as a basis for the `SSSPEdge` needs to be parametrized with the source vertex's type to know how to extract its state information.

{{{
import com.signalcollect.javaapi.*;

@SuppressWarnings("serial")
public class SSSPEdge extends DefaultEdge<SSSPNode> {

	SSSPEdge(int sourceID, int targetID) {
		super(sourceID, targetID);
	}

	@Override
	public Object signal(SSSPNode sourceVertex) {
		if(sourceVertex.getState()<Integer.MAX_VALUE) { //To prevent integer overflow.
			return sourceVertex.getState() + (int)this.weight();
		}
		else {
			return sourceVertex.getState();
		}
	}
}
}}}

== Run the algorithm ==
We now have implemented the components of the graph that are responsible for computing the states based on signals from neighboring vertices and for computing and forwarding signals from one vertex to its neighboring vertices. This is it! To build an SSSP graph all we have to do is to construct a graph with the elements above and start the computation. For the SSSP we don't need to enforce synchronous execution because the algorithm will also run correctly for asynchronous execution. After the termination of the algorithm we print out all some statistics about the execution and then print each vertex to the standard output to check whether the distances were computed correctly.
 
{{{
import com.signalcollect.ExecutionInformation;
import com.signalcollect.Graph;
import com.signalcollect.Vertex;
import com.signalcollect.javaapi.*;

public class SSSP {

	public static void main(String[] args) {
		Graph graph = GraphBuilder.build();
		
		graph.addVertex(new SSSPNode(1, 0));
		graph.addVertex(new SSSPNode(2));
		graph.addVertex(new SSSPNode(3));
		graph.addVertex(new SSSPNode(4));
		graph.addVertex(new SSSPNode(5));
		graph.addVertex(new SSSPNode(6));
		
		graph.addEdge(new SSSPEdge(1, 2));
		graph.addEdge(new SSSPEdge(2, 3));
		graph.addEdge(new SSSPEdge(3, 4));
		graph.addEdge(new SSSPEdge(1, 5));
		graph.addEdge(new SSSPEdge(4, 6));
		graph.addEdge(new SSSPEdge(5, 6));
		
		ExecutionInformation stats = graph.execute();
		System.out.println(stats);
		
		//print the state of every vertex in the graph.
		graph.foreachVertex(new VertexCommand(){
			@Override
			public void f(Vertex v) {
				System.out.println(v);
			}
		});
		graph.shutdown();
	}
}
}}}

_*Note:* Eclipse might complain about the `graph.foreachVertex(..);` invocation. Don't worry this is a problem with the IDE and not with the code._

After the execution of the algorithm the print out of the vertices should look similar to this this (the execution of the `graph.foreachVertex(..);` method is not guarantied):

{{{
SSSPNode(id=2, state=1)
SSSPNode(id=4, state=3)
SSSPNode(id=6, state=2)
SSSPNode(id=1, state=0)
SSSPNode(id=3, state=2)
SSSPNode(id=5, state=1)
}}}


 