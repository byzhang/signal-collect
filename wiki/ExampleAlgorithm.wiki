#summary An example of a simple Signal/Collect computation.

= Example Algorithm - Tutorial =

This example algorithm shows how to use the signal-collect computation model for a simple simulation.

== The general algorithm ==

For our example we use the a variation of the [http://web.mit.edu/rajsingh/www/lab/alife/schelling.html Schelling Segregation model]. Let's assume te following properties:

  * We have a space represented by  a two dimensional m*n grid. This space could be thought of a neighborhood in a city district. Each cell in this grid could stand for a housing unit that can be occupied by residents of a binary type e.g. rich or poor.
  * Each cell in the grid has a preference for its surrounding cells to be the same type. E.g. a resident could require to have at least 40% of its neighbors of the same income as himself.
  * If the minimum conformity is not met, the cell changes its state. E.g. the resident moves away and the unit is occupied by someone from the other income level.

The model states that even if the individual cells are relatively tolerant the space will be clearly separated.

== Design of the Signal-Collect computation ==

To map the algorithm described above in a computation suitable for the signal collect we need to construct a graph from the given grid. For this reason we view each cell as a vertex that is connected to its neighboring vertices. 

{{{
class SegregationAgent(id: Any, initialState: Int, equalityThreshold: Float) extends DataGraphVertex(id, initialState) {
  type Signal = Int
  var changedState: Boolean = false

  def collect(oldState: State, mostRecentSignals: Iterable[Int]): Int = {
    val equalCount = mostRecentSignalMap.values.foldLeft(0)((b, otherState) => if (otherState == this.state) b + 1 else b)
    val totalNeighbors = mostRecentSignalMap.size
    if (equalCount.toFloat / totalNeighbors >= equalityThreshold) {
      changedState = false
      this.state
    } else {
      changedState = true
      ((this.state) + 1) % 2
    }
  }

  override def scoreSignal = if (changedState || lastSignalState == None) 1 else 0
}
}}}


And the Application itself:

{{{

object SchellingSegregation extends App {
  val graph = GraphBuilder.build

  //dimensions of the grid
  val m = 40
  val n = 20

  //create all agents
  for (i <- 0 until (m * n)) {
    graph.addVertex(new SegregationAgent(i, (Math.random * 2.0).floor.toInt, 0.4f))
  }

  //create all connections

  /*
   * N1 | N2 | N3
   * ------------
   * N4 | XX | N5
   * ------------
   * N6 | N7 | N8
   */

  for (i <- 0 until m) {
    for (j <- 0 until n) {
      if ((i - 1) >= 0) { //N4
        graph.addEdge(new StateForwarderEdge(j * m + i, j * m + i - 1))
        if ((j - 1) >= 0) { //N1

          graph.addEdge(new StateForwarderEdge(j * m + i, (j - 1) * m + i - 1))
        }
        if ((j + 1) < n) { //N6
          graph.addEdge(new StateForwarderEdge(j * m + i, (j + 1) * m + i - 1))
        }
      }
      if ((i + 1) < m) { //N5
        graph.addEdge(new StateForwarderEdge(j * m + i, j * m + i + 1))
        if ((j - 1) >= 0) { //N3
          graph.addEdge(new StateForwarderEdge(j * m + i, (j - 1) * m + i + 1))
        }
        if ((j + 1) < n) { //N8
          graph.addEdge(new StateForwarderEdge(j * m + i, (j + 1) * m + i + 1))
        }
      }
      if ((j - 1) >= 0) { //N2
        graph.addEdge(new StateForwarderEdge(j * m + i, (j - 1) * m + i))
      }
      if ((j + 1) < n) { //N2
        graph.addEdge(new StateForwarderEdge(j * m + i, (j + 1) * m + i))
      }
    }
  }

  val stats = graph.execute(ExecutionConfiguration.withTimeLimit(5000))
  println(stats)
  for(i <- 0 until (m*n)) {
    if(i%m == 0) {
      print("\n")
    }
    val state: Option[Int] = graph.forVertexWithId(i, (v: SegregationAgent) => v.state)
    print(state.get)
  }
  graph.shutdown
}
}}}