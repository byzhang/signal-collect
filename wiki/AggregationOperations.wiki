#summary Everything about Aggregation Operations
#labels Phase-Implementation

=What aggregation operations are used for=
Aggregation functions calculate a global value over the entire graph. This has many uses:
  * Calculating the final result of a computation
  * Compute a global normalization constant
  * Sample some values from the graph
  * Specifying a global termination condition

=How to use aggregation operations=
An aggregation function has to implement the AggregationOperation trait.
{{{
trait AggregationOperation[ValueType] {
  def extract(v: Vertex): ValueType
  def aggregate(a: ValueType, b: ValueType): ValueType
  val neutralElement: ValueType
}
}}}

Every aggregation operation aggregates some value of type `ValueType` over all the vertices in a graph. 
The values that get aggregated first get extracted from the vertices by the `extractor` function. The extracted values then  get aggregated by the aggregation function specified by the `operation` parameter. There is no guarantee about the order in which this operation gets executed on the graph. Also required is the parameter `neutralElement`, which represents the neutral element of the aggregation function `operation`: `operation(x, neutralElement) == x`.

Once an instance of this trait has been created it can be submitted to the graph by calling the `aggregate` function on an instance of `Graph`. The returned result is the aggregated value:

{{{
trait Graph {
  def aggregate[ValueType](aggregationOperation: AggregationOperation[ValueType]): ValueType
  ...
}
}}}

In order to use an aggregation operation as a termination condition an instance of `GloablTerminationCondition`has to be specified:
abstract class GlobalTerminationCondition[ValueType](
  val aggregationOperation: AggregationOperation[ValueType],
  val aggregationInterval: Long = 1000l) {
  def shouldTerminate(value: ValueType): Boolean
}

GloablTerminationCondition defines a termination condition that depends on the global state of the graph. The parameter `aggregationOperation` is used to compute the globally aggregated value, while the parameter `aggregationInterval` has a different semantic depending on the execution type: In a synchronous computation it specifies the aggregation interval in computation steps. An interval of 2 would mean that the global aggregation condition is checked every other computation step. In an asynchronous computation the parameter `aggregationInterval` specifies the interval between in milliseconds. The predicate `shouldTerminate` is applied to the result of the aggregation operation. If it returns true this means that the computation should end.

=Usage examples=