#summary Architecture of the Signal/Collect framework
#labels Phase-Design

http://signal-collect.googlecode.com/svn/wiki/images/architecture.png

The Signal/Collect architecture is designed to be easily extensible to a distributed setting. For this purpose much of the complexity of the distributed version will be handled inside the [http://code.google.com/p/signal-collect/source/browse/trunk/core/src/main/scala/com/signalcollect/interfaces/MessageBus.scala MessageBus] implementation, while as much as possible of the high-level computation coordination will be oblivious of the local/distributed setting. There are default implementations for all components, but we also strived to make the design modular such that the concrete MessageBus/Worker/Storage/VertexToWorkerMapper/Logger implementation is pluggable.

The main API offered to users of Signal/Collect is the Graph, which extends GraphEditor. The implementation created by GraphBuilder is of type DefaultGraph.

DefaultGraph delegates GraphEditor calls to an instance of DefaultGraphEditor and execution/aggregation related calls to an instance of Coordinator.

Coordinator in turn coordinates computations by controlling workers using the WorkerApi, which has a WorkerProxy instance for each worker. WorkerProxy implements workers by doing remote procedure calls over the MessageBus implementation DefaultMessageBus.

The workers (by default of type LocalWorker) receive commands via the MessageBus. Some worker commands will initiate a reply from the worker, but this is entirely specified within the command, the worker is oblivious to the communication protocol used.

The worker itself stores instances of Vertex in Storage, which by default is of type InMemoryStorage.